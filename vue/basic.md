### 基础

---

#### 创建 Vue 应用

每个 Vue 应用都是通过 `createApp` 函数创建一个新的**应用实例**。

应用实例必须在调用了 `.mount()` 方法后才能被**渲染**出来，该方法接受一个“容器”参数，应该始终在整个应用配置和资源注册完成后被调用。

应用实例会暴露一个 `.config` 对象允许配置一些**应用级的选项**，还提供了一些方法来注册**应用范围内可用的资源**。([API参考](https://cn.vuejs.org/api/application.html))

---

#### 模板语法

**声明式**地将其组件实例的数据绑定到呈现的 DOM 上。

模板绑定仅支持单一表达式，也就是一段能够被求值的 JavaScript 代码。
模板中的表达式将被沙盒化，仅能够访问到有限的全局对象列表。可以自行在 `app.config.globalProperties` 上显式地添加它们。

指令 attribute 的期望值为一个 JavaScript 表达式 (除了少数几个例外，即 v-for、v-on 和 v-slot)。
动态参数：同样在指令参数上也可以使用一个 JavaScript 表达式，需要包含在一对方括号内。
动态参数中表达式的值应当是一个字符串，或者是 null。
动态参数表达式因为某些字符的缘故有一些语法限制，比如空格和引号。
如果你需要传入一个复杂的动态参数，我们推荐使用计算属性替换复杂的表达式。
当使用 DOM 内嵌模板 (直接写在 HTML 文件里的模板) 时，我们需要避免在名称中使用大写字母，因为浏览器会强制将其转换为小写。

修饰符是以点开头的特殊后缀，表明指令需要以一些特殊的方式被绑定。

**Name:Argument.Modifiers=Value**

Vue 提供了许多[**内置指令**](https://cn.vuejs.org/api/built-in-directives.html)。

|需求|语法|注意事项|
|--|--|--|
|文本插值|"Mustache"语法||
|原始 HTML|v-html 指令|在网站上动态渲染任意 HTML 是非常危险的，因为这非常容易造成 XSS 漏洞|
|Attribute 绑定|v-bind 指令|1. 布尔型 Attribute 绑定为真值或一个空字符串，会被认为为真 <br/> 2. 可以动态绑定多个值|

![总结]('./images/m.png')

---

#### 响应式基础

DOM 更新时机：Vue 会在“next tick”更新周期中缓冲所有状态的修改，以确保不管你进行了多少次状态修改，每个组件都只会被更新一次。要等待 DOM 更新完成后再执行额外的代码，可以使用 nextTick() 全局 API。

---

#### 计算属性

**计算属性值会基于其响应式依赖被缓存。**一个计算属性仅会在其响应式依赖更新时才重新计算。这意味着只要 author.books 不改变，无论多少次访问 publishedBooksMessage 都会立即返回先前的计算结果，而不用重复执行 getter 函数。

计算属性默认是只读的。当你尝试修改一个计算属性时，你会收到一个运行时警告。只在某些特殊场景中你可能才需要用到“可写”的属性，你可以通过同时**提供 getter 和 setter 来创建**。

---

#### Class 与 Style 绑定

---

#### 条件渲染

v-if 是“真实的”按条件渲染，因为它确保了在切换时，条件区块内的事件监听器和子组件都会被销毁与重建。v-if 也是惰性的：如果在初次渲染时条件值为 false，则不会做任何事。条件区块只有当条件首次变为 true 时才被渲染。相比之下，v-show 简单许多，元素无论初始条件如何，始终会被渲染，只有 CSS display 属性会被切换。总的来说，v-if 有更高的切换开销，而 v-show 有更高的初始渲染开销。因此，如果需要频繁切换，则使用 v-show 较好；如果在运行时绑定条件很少改变，则 v-if 会更合适。

---

#### 列表渲染

v-for 可以直接接受一个整数值。在这种用例中，会将该模板基于 1...n 的取值范围重复多次。

Vue 默认按照“就地更新”的策略来更新通过 v-for 渲染的元素列表。当数据项的顺序改变时，Vue 不会随之移动 DOM 元素的顺序，而是就地更新每个元素，确保它们在原本指定的索引位置上渲染。默认模式是高效的，但只适用于列表渲染输出的结果不依赖子组件状态或者临时 DOM 状态 (例如表单输入值) 的情况。为了给 Vue 一个提示，以便它可以跟踪每个节点的标识，从而重用和重新排序现有的元素，你需要为每个元素对应的块提供一个唯一的 key attribute。推荐在任何可行的时候为 v-for 提供一个 key attribute，除非所迭代的 DOM 内容非常简单 (例如：不包含组件或有状态的 DOM 元素)，或者想有意采用默认行为来提高性能。

数组变化侦测：1. 变更方法：push()、pop()、shift()、unshift()、splice()、sort()、reverse()。2. 替换一个数组：例如 filter()、concat() 、 slice()。

---

#### 事件处理

事件处理器 (handler) 的值可以是：1. 内联事件处理器：事件被触发时执行的内联 JavaScript 语句 (与 onclick 类似)。2. 方法事件处理器：一个指向组件上定义的方法的属性名或是路径。

在内联事件处理器中访问原生 DOM 事件。你可以向该处理器方法传入一个特殊的 $event 变量，或者使用内联箭头函数。

Vue 为 v-on 提供了事件修饰符。修饰符是用 . 表示的指令后缀，包含以下这些：.stop、.prevent、.self、.capture、.once、.passive。使用修饰符时需要注意调用顺序，因为相关代码是以相同的顺序生成的。

在监听键盘事件时，我们经常需要检查特定的按键。Vue 允许在 v-on 或 @ 监听按键事件时添加按键修饰符。一些常用的按键提供了别名：.enter、.tab、.delete (捕获“Delete”和“Backspace”两个按键)、.esc、.space、.up、.down、.left、.right。可以使用以下系统按键修饰符来触发鼠标或键盘事件监听器，只有当按键被按下时才会触发：.ctrl、.alt、.shift、.meta。

.exact 修饰符允许控制触发一个事件所需的确定组合的系统按键修饰符。

鼠标按键修饰符：.left、.right、.middle，这些修饰符将处理程序限定为由特定鼠标按键触发的事件。

---

#### 表单输入绑定

可以将多个复选框绑定到同一个数组或集合的值。

默认情况下，v-model 会在每次 input 事件后更新数据 (IME 拼字阶段的状态例外)。你可以添加 lazy 修饰符来改为在每次 change 事件后更新数据。

如果你想让用户输入自动转换为数字，你可以在 v-model 后添加 .number 修饰符来管理输入。如果该值无法被 parseFloat() 处理，那么将返回原始值。

如果你想要默认自动去除用户输入内容中两端的空格，你可以在 v-model 后添加 .trim 修饰符。

---

#### 生命周期钩子

![生命周期钩子]('./images/r.png')

---

#### 侦听器

要在状态变化时执行一些“副作用”：例如更改 DOM，或是根据异步操作的结果去修改另一处的状态。

watch 选项也支持把键设置成用 . 分隔的路径。

watch 默认是浅层的：被侦听的属性，仅在被赋新值时，才会触发回调函数——而嵌套属性的变化不会触发。如果想侦听所有嵌套的变更，你需要深层侦听器。

可以用一个对象来声明侦听器，这个对象有 handler 方法和 immediate: true 选项，这样便能强制回调函数立即执行。

如果想在侦听器回调中能访问被 Vue 更新之后的 DOM，你需要指明 flush: 'post' 选项。

可以使用组件实例的 $watch() 方法来命令式地创建一个侦听器。如果要在特定条件下设置一个侦听器，或者只侦听响应用户交互的内容，这方法很有用。它还允许你提前停止该侦听器。在少数情况下，你的确需要在组件卸载之前就停止一个侦听器，这时可以调用 $watch() API 返回的函数。

---

#### 模板引用

ref 是一个特殊的 attribute，和 v-for 章节中提到的 key 类似。它允许我们在一个特定的 DOM 元素或子组件实例被挂载后，获得对它的直接引用。这可能很有用，比如说在组件挂载时将焦点设置到一个 input 元素上，或在一个元素上初始化一个第三方库。

ref 数组并不保证与源数组相同的顺序。

除了使用字符串值作名字，ref attribute 还可以绑定为一个函数，会在每次组件更新时都被调用。该函数会收到元素引用作为其第一个参数。

如果一个子组件使用的是选项式 API ，被引用的组件实例和该子组件的 this 完全一致，这意味着父组件对子组件的每一个属性和方法都有完全的访问权。这使得在父组件和子组件之间创建紧密耦合的实现细节变得很容易，当然也因此，应该只在绝对需要时才使用组件引用。大多数情况下，你应该首先使用标准的 props 和 emit 接口来实现父子组件交互。

---

#### 组件基础











































































